<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="copyright" content="Data source: Genomes on a Tree (GoaT). Used with permission." />
    <meta name="author" content="Fang Chen" />
    <title>EBP Affiliate Progress</title>
    <script src="../config.js"></script>
    <script src="./echarts.min.js"></script>
    <script src="./utils.js"></script>
    <script src="./services.js"></script>
    <script src="./projectsMap.js"></script>
    <style>
        #chartContainer1,
        #chartContainer2,
        #chartContainer3
          {
            height: 80vh;
            width: 70%;
            /* min-width: 500px;    */
            margin: 20px auto;
        }
        /* Add container padding to prevent footer overlap */
        .container {
          padding-bottom: 30px;
        }
        /* Footer styles */
        #footer {
            position: fixed;
            bottom: 0;
            width: 100%;
            background-color: rgba(248, 249, 250, 0.95);
            color: #333;
            text-align: center;
            padding: 5px;
            z-index: 9999;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
            font-size: 14px;
        }
    </style>
  </head>
  <body>
    <div class="container">
   <div id="chartContainer1"></div>
   <div id="chartContainer2"></div>
   <div id="chartContainer3"></div>

    <div id="footer">
        <div id="copyright">Data source: Genomes on a Tree (GoaT). Used with permission.</div>
    </div>
    </div>

    <script>
        let chartInstance1 = null
        let chartInstance2 = null
        let chartInstance3 = null

      window.onload = function () {
        const finalReportUrl = 'https://goat.genomehubs.org/api/v2/report?report=histogram&x=tax_tree%282759%29%20AND%20long_list%20AND%20bioproject%3DPRJNA533106&rank=species&includeEstimates=false&cat=assembly_level%3Dcontig%2Cscaffold%2Cchromosome%2Ccomplete%20genome&xOpts=%2C%2C55%2C%2CEBP%20Affiliate&caption=Assemblies%20available%20on%20INSDC%20for%20target%20species%20across%20EBP-affiliated%20projects.%20Note%20that%20umbrella%20projects%20will%20inherit%20counts%20from%20their%20sub-projects%20and%20that%20overlapping%20targets%20sequenced%20by%20at%20least%20one%20EBP%20affiliate%20will%20appear%20as%20complete%20in%20all%20projects%20targeting%20that%20taxon&taxonomy=ncbi&result=taxon&queryId=vLCkKyxY2S'
        fetchData(finalReportUrl).then(res => {
          const categories = res.report.report.histogram.histograms.buckets.filter(item => (!!item))
          const searchRequests = []
          const validCategories = []
          
          categories.forEach(projectName => {
            const projectId = projectsMap[projectName]
            if(projectId) {
                  const searchUrl = `https://goat.genomehubs.org/api/v2/search?query=bioproject%3D${projectId}%20AND%20tax_rank%28species%29&result=taxon&includeEstimates=true&taxonomy=ncbi&size=9900&offset=0&fields=genome_size%2Cassembly_level%2Cassembly_span`
                  validCategories.push(projectName)
                  searchRequests.push(fetchData(searchUrl))
                }
              })
              
              const speciesCounts = { 'chromosome': [], 'complete genome': [], 'contig': [], 'scaffold': [] }
              const genomes = { 'chromosome': [], 'complete genome': [], 'contig': [], 'scaffold': [] }
              const assemblies = { 'chromosome': [], 'complete genome': [], 'contig': [], 'scaffold': [] }

              Promise.all(searchRequests).then(results => {
                results.forEach((projectResult, index) => {
                  // Initialize counts and sums for this project to 0
                  Object.keys(speciesCounts).forEach(key => speciesCounts[key][index] = 0);
                  Object.keys(genomes).forEach(key => genomes[key][index] = 0);
                  Object.keys(assemblies).forEach(key => assemblies[key][index] = 0);

                  if (projectResult.results) {
                      projectResult.results.forEach(item => {
                        const { genome_size, assembly_span, assembly_level } = item.result.fields;
                        if (assembly_level && assembly_level.value) {
                          const level = assembly_level.value.toLowerCase();
                          const genome = genome_size ? genome_size.value : 0;
                          const assembly = assembly_span ? assembly_span.value : 0;
                          
                          if (speciesCounts.hasOwnProperty(level)) {
                            speciesCounts[level][index]++;
                            genomes[level][index] += genome;
                            assemblies[level][index] += assembly;
                          }
                        }
                      });
                  }
                });
                
                const myData1 = {
                    report: {
                        report: {
                            yLabel: "Count of species",
                            histogram: {
                                histograms: {
                                    byCat: speciesCounts,
                                    buckets: []
                                }
                            }
                        }
                    }
                }
                const { series: series1 } = getDefaultStackedBarData(myData1)
                const title1 = 'Count of species'
                chartInstance1 = initEchart({series: series1, categories: validCategories}, 'chartContainer1', title1)

                const myData2 = {
                    report: {
                        report: {
                            yLabel: "Sum of genome_size",
                            histogram: {
                                histograms: {
                                    byCat: genomes,
                                    buckets: []
                                }
                            }
                        }
                    }
                }
                const myData3 = {
                    report: {
                        report: {
                            yLabel: "Sum of assembly_span",
                            histogram: {
                                histograms: {
                                    byCat: assemblies,
                                    buckets: []
                                }
                            }
                        }
                    }
                }
                  chartInstance2 = initEchart({series: getDefaultStackedBarData(myData2).series, categories: validCategories}, 'chartContainer2', 'Sum of genome_size')
                  chartInstance3 = initEchart({series: getDefaultStackedBarData(myData3).series, categories: validCategories}, 'chartContainer3', 'Sum of assembly_span')
            })
        })
      };

      function initEchart(data, containerId, yLabel) {
        const chartDom = document.getElementById(containerId);
        const myChart = echarts.init(chartDom);
        const arr = []
        const len = data.categories.length
        for(let i = 0; i < len; i++) {
          const list = []
          list.push(data.categories[i])

          for(let j = 0; j < data.series.length; j++) {
            list.push(data.series[j].data[i])
          }
          arr.push(list)
        }

        // Sort based on total sum of all values
        arr.sort((a, b) => {
          let sum1 = 0;
          let sum2 = 0;
          // Start from index 1 since index 0 is the category name
          for(let i = 1; i < a.length; i++) {
            sum1 += a[i] || 0;
            sum2 += b[i] || 0;
          }
          return sum2 - sum1;
        });

        // Reconstruct the data arrays after sorting
        const sortedCategories = [];
        const sortedData = data.series.map(() => []);

        arr.forEach((item, index) => {
          sortedCategories.push(item[0]);
          for(let j = 0; j < data.series.length; j++) {
            sortedData[j].push(item[j + 1]);
          }
        });

        // Update the original data structure
        data.categories = sortedCategories;
        data.series.forEach((series, index) => {
          series.data = sortedData[index];
        });

        const option = {
          legend: {
            show: true,
            selectedMode: false,
            data: ['contig', 'scaffold', 'chromosome', 'complete genome'], // Reorder legend items
            textStyle: {
              color: '#000',
              fontSize: 12,
              fontWeight: 'bold',
            }
          },
          color: ['#FF0000', '#00FF00', '#0000FF', '#FFA500'], // Higher contrast colors with distinct color for complete genome
          grid: {
            left: '7%',  // Decreased left margin
            right: '2%',
            bottom: '10%',
            containLabel: true
          },
          yAxis: {
            type: "value",
            name: yLabel,
            nameLocation: 'middle',
            nameRotate: 90,
            nameGap: 45,  // Adjust gap to bring label closer
            nameTextStyle: {
              fontWeight: 'bold',
              fontSize: 14,
            },
            axisLine: {
              show: true,
              lineStyle: {
                color: "#000",
                width: 1,
              },
            },
            axisLabel: {
              show: true,
              color: "#000",
              fontSize: 12,
              margin: 5, // Move labels closer to the axis
              formatter: function (value) {
                if (containerId === 'chartContainer1') {
                  return value.toLocaleString(); // Show complete numbers for count of species
                } else if (containerId === 'chartContainer2' || containerId === 'chartContainer3') {
                  return (value / 1e12).toFixed(1) + 'T'; // Convert to T format for genome size and assembly span
                }
                return formatNumber(value);
              }
            },
            splitLine: {
              show: true,
              lineStyle: {
                color: '#ccc'
              }
            },
            interval: containerId === 'chartContainer1' ? 500 : 
                      (containerId === 'chartContainer2' || containerId === 'chartContainer3') ? 0.5e12 : 'auto', // Set interval to 0.5T for genome size and assembly span
            minInterval: containerId === 'chartContainer1' ? 500 : 
                        (containerId === 'chartContainer2' || containerId === 'chartContainer3') ? 0.5e12 : 1, // Ensure minimum interval of 0.5T for genome size and assembly span
          },
          xAxis: {
            type: "category",
            data: arr.map(item => (item[0])), // Create an array of years from 2006 to 2024
            axisLine: {
              show: true,
              lineStyle: {
                color: "#000",
                width: 1,
              },
              
            },
            axisLabel: {
              show: true,
              color: "#000",
              fontSize: 12,
              rotate: 45,
        
            //   fontFamily: 'Times News Roman' 
            // fontWeight: 700
            },
            name: "EBP affiliates", // Add this line
            nameLocation: 'middle', // Add this line to place the label in the middle 
            nameGap: 60,  // Adjust gap to bring label closer
            nameTextStyle: {
              fontWeight: 'bold',
              fontSize: 14,
              padding: [10, 0, 0, 0], // Adjust padding to move the label slightly away from the axis
            },
            splitLine: {
              show: false,
            },
          },
          tooltip: {
            trigger: "axis",
            formatter: function (params) {
              var res = params
                .map(function (item) {
                  return item.seriesName + ": " + (item.value || 0).toLocaleString();
                })
                .join("<br/>");

              // For total calculation
              var total = 0;
              params.forEach(function (item) {
                total += item.value || 0;
              });

              return res + "<br/>Total: " + total.toLocaleString();
            },
          },
          series: data.series,
        };
        myChart.setOption(option);
      
        return myChart
      }
    </script>
  </body>
</html>
